"""
Process Image Files for iCloud Re-ingestion

This module reads the CSV report generated by evaluate_image_files.py,
and for each image marked with action 'move', copies the image to a designated output folder.
The output folder is set by the global variable PROCESSED_IMAGE_FOLDER_PATH.

The script preserves the original filenames and prints progress to the console.
"""

import os
import pandas as pd
import shutil
from datetime import datetime

# Configuration
INPUT_CSV_FOLDER_PATH = "report"
INPUT_CSV_FILE_NAME = "icloud_image_report.csv"
PROCESSED_IMAGE_FOLDER_PATH = "data/processed_images/2018"
OUTPUT_CSV_FOLDER_PATH = "report"
OUTPUT_CSV_FILE_NAME = "icloud_image_report_processed.csv"

# Read the CSV
input_csv_path = os.path.join(INPUT_CSV_FOLDER_PATH, INPUT_CSV_FILE_NAME)
if not os.path.exists(input_csv_path):
    raise FileNotFoundError(f"Input CSV not found: {input_csv_path}")
df = pd.read_csv(input_csv_path, sep='@', names=['file', 'datetime', 'action', 'reason'], dtype=str)

# Track processed files
df['processed'] = ''

# Ensure output folder exists
os.makedirs(PROCESSED_IMAGE_FOLDER_PATH, exist_ok=True)

# Process each row in the DataFrame
for idx, row in df.iterrows():
    if row['action'] != 'move':
        continue
    src_path = row['file']
    file_name = os.path.basename(src_path)
    # Get date for prefix from CSV datetime column
    prefix = "unknown_"
    csv_datetime = row.get('datetime')
    if csv_datetime and pd.notna(csv_datetime) and csv_datetime.strip():
        try:
            # EXIF format is 'YYYY:MM:DD HH:MM:SS'
            dt = datetime.strptime(csv_datetime, '%Y:%m:%d %H:%M:%S')
            prefix = dt.strftime('%Y%m%d_%H%M%S-')
        except Exception as e:
            print(f"Warning: Could not parse datetime '{csv_datetime}' for {src_path}: {e}")

    unique_file_name = f"{prefix}{file_name}"
    dst_path = os.path.join(PROCESSED_IMAGE_FOLDER_PATH, unique_file_name)
    try:
        shutil.copy2(src_path, dst_path)
        df.at[idx, 'processed'] = dst_path
        print(f"Copied: {src_path} -> {dst_path}")
    except Exception as e:
        df.at[idx, 'processed'] = f"error: {e}"
        print(f"Error copying {src_path}: {e}")

# Save the updated DataFrame
os.makedirs(OUTPUT_CSV_FOLDER_PATH, exist_ok=True)
output_csv_path = os.path.join(OUTPUT_CSV_FOLDER_PATH, OUTPUT_CSV_FILE_NAME)
df.to_csv(output_csv_path, sep='@', index=False)
print(f"Done. Results written to {output_csv_path}")
